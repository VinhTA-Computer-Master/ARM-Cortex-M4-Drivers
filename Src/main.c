/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2020 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */


#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include "../Driver/Inc/stm32f4xx.h"
#include "../Driver/Inc/gpio_driver.h"
#include "../Driver/Inc/sysclk_driver.h"
#include "../Driver/Inc/timer_driver.h"
#include "../Driver/Inc/LCD1602_driver.h"
#include "../Driver/Inc/I2C_driver.h"
#include "../Driver/Inc/DS1307_RTC_driver.h"
#include "../Driver/Inc/LCD2004_I2C_driver.h"
#include "../Driver/Inc/RNG_driver.h"
#include "Matrix_Chain_Multiplication.h"


#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


// Routine signals
volatile bool start = false;
volatile bool LCD_Init_Signal = false;
volatile bool I2C_Rx_Display = false;
volatile bool Frequency_Calibrate = false;
volatile bool Delay_Test = false;

int volatile run = 1;
int volatile led = 0;
bool volatile fast_timer = false;
unsigned volatile cycle_freq = 0;
volatile char I2C2_RX_Buffer[32];

GPIO_Handle_t PA0, PD12, PD13, PD14, PD15;	// PA0 connected to button, PD12/13/14/15 connected to LEDs

void EXTI0_IRQHandler(void){
	GPIO_IRQHandling(0);
	start = true;
}

void EXTI1_IRQHandler(void){
	GPIO_IRQHandling(1);
	RTC_Cycle++;
}

void EXTI2_IRQHandler(void){
	LCD_Init_Signal = true;
	Frequency_Calibrate = true;
	GPIO_IRQHandling(2);
}

void EXTI3_IRQHandler(void){
	Delay_Test = true;
	GPIO_IRQHandling(3);
}

void LCD2004_App(){
	GPIO_WriteToPin(&PD13, 0);

	LCD2004_Config_t LCD2004_conf = {true, true, true, true, 2, 0, 0};
	LCD2004_Init(&LCD2004_conf);
	LCD2004_WriteString(&LCD2004_conf, "Hello Vinh!", 11);
	LCD2004_SetCursor(&LCD2004_conf, 1, 0);
	LCD2004_WriteString(&LCD2004_conf, "Press button", 12);
	LCD2004_SetCursor(&LCD2004_conf, 2, 0);
	LCD2004_WriteString(&LCD2004_conf, "For time show", 13);

	while(!start);

	while(1){
		unsigned msec = get_sys_msec();		// 4B msec at most
		char msec_buffer[10];				// -> 10 digits allocated
		itoa(msec, msec_buffer, 10);
		char cycle_buffer[9];
		itoa(RTC_Cycle, cycle_buffer, 10);

		char msec_print[20] = "Sys msec: ";
		strcat(msec_print, msec_buffer);
		char cycle_print[20] = "Sys cycle: ";
		strcat(cycle_print, cycle_buffer);

		LCD2004_ClearScreen(&LCD2004_conf);
		LCD2004_WriteString(&LCD2004_conf, msec_print, 20);
		LCD2004_SetCursor(&LCD2004_conf, 1, 0);
		LCD2004_WriteString(&LCD2004_conf, cycle_print, 20);

		msec_delay(1000);
	}
}

void I2C_Tx_Callback(int I2C_num){
	GPIO_WriteToPin(&PD13, 0);
}

void I2C_Rx_Callback(int I2C_num){

}

void I2C_Error_Callback(int I2C_num, I2C_Error err){

}

/*
 * I2C1: PB6/8 (SCL) & PB7/9 (SDA)
 * I2C2: PB10/PF1/PH4 (SCL) & PB11/PF0/PH5 (SDA)
 * I2C3: PH7/PA8 (SCL) & PH8/PC9 (SDA)
 *
 */

// This app uses I2C2 module to communicate with Arduino @ addr 0x68
void I2C2_App(){
	GPIO_WriteToPin(&PD13, 0);

	I2C2_conf.master_tx_callback = &I2C_Tx_Callback;
	I2C2_conf.master_rx_callback = &I2C_Rx_Callback;
	I2C_Init(&I2C2_conf);

	char data[39] = "Hello Arduino! Calling from STM Master.";

	GPIO_WriteToPin(&PD13, 1);
	I2C_SendData(&I2C2_conf, 0x68, &data, 20);	// Arduino only ACK 32 bytes in a transaction!
	while(I2C_isBusy(&I2C2_conf));

	GPIO_WriteToPin(&PD13, 1);
	I2C_SendData(&I2C2_conf, 0x68, &data[20], 19);
	while(I2C_isBusy(&I2C2_conf));

	while(1){
		msec_delay(2000);

		unsigned msec = get_sys_msec();		// 4B msec at most
		char msec_buffer[10];				// -> 10 digits allocated
		itoa(msec, msec_buffer, 10);

		char data_buffer[23] = "Master msec: ";
		strcat(data_buffer, msec_buffer);

		GPIO_WriteToPin(&PD13, 1);
		I2C_SendData(&I2C2_conf, 0x68, &data_buffer, 23);
		while(I2C_isBusy(&I2C2_conf));
	}
}

// This app is used to calibrate TIM parameters to match as close to msec as possible
// Difference between systime and RTC time is output to LCD2004
void TIM_RTC_Calibrate(){
	// Reset time keepers
	RTC_Cycle = 0;
	systick_overlap = 0;
	TIM5->CNT = 0;

	GPIO_Handle_t PA2;	// Manual pin for sysclk freq calibrate
	GPIO_Init(&PA2, 'A', 2);
	GPIO_SetModer(&PA2, MODER_INPUT);
	GPIO_IRQConfig(&PA2, GPIO_EXTI_INTERRUPT, GPIO_EXTI_EDGE_RISE);

	GPIO_Handle_t PA3;	// Manual pin for delay function test - oscilloscope required
	GPIO_Init(&PA3, 'A', 3);
	GPIO_SetModer(&PA3, MODER_INPUT);
	GPIO_IRQConfig(&PA3, GPIO_EXTI_INTERRUPT, GPIO_EXTI_EDGE_RISE);

	GPIO_Handle_t PA5;	// In delay test, toggle signal on PA5 every 1ms for 10 times
	GPIO_Init(&PA5, 'A', 5);
	GPIO_SetModer(&PA5, MODER_OUTPUT);

	LCD2004_Config_t LCD2004_conf = {false, false, true, true, 2, 0, 0};
	LCD2004_Init(&LCD2004_conf);
	LCD2004_WriteString(&LCD2004_conf, "Calibrate systime", 17);
	LCD2004_SetCursor(&LCD2004_conf, 1, 0);
	LCD2004_WriteString(&LCD2004_conf, "Press button...", 15);
	LCD2004_SetCursor(&LCD2004_conf, 2, 0);
	LCD2004_WriteString(&LCD2004_conf, "  to continue", 13);

	while(!start);

	Frequency_Calibrate = false;
	Delay_Test = false;

	while(1){
		if(Frequency_Calibrate){
			// Avoid using functions for minimal overhead
			unsigned systick = get_sys_tick();
			unsigned cycle = RTC_Cycle;
			unsigned overlap = systick_overlap;
			unsigned freq = (((0xFFFFFFFF/cycle)*overlap) << 12) + ((systick/cycle) << 12);

			char freq_buffer[10];
			utoa(sysclk_frequency, freq_buffer, 10);

			LCD2004_ClearScreen(&LCD2004_conf);
			LCD2004_WriteString(&LCD2004_conf, "Sysclk Calibrated", 17);
			LCD2004_SetCursor(&LCD2004_conf, 1, 0);
			LCD2004_WriteString(&LCD2004_conf, "Old Freq: ", 10);
			LCD2004_WriteString(&LCD2004_conf, freq_buffer, 10);
			LCD2004_SetCursor(&LCD2004_conf, 2, 0);

			sysclk_frequency = freq;
			memset(freq_buffer, 0, 10);
			utoa(sysclk_frequency, freq_buffer, 10);

			LCD2004_WriteString(&LCD2004_conf, "New Freq: ", 10);
			LCD2004_WriteString(&LCD2004_conf, freq_buffer, 10);
			LCD2004_SetCursor(&LCD2004_conf, 3, 0);
			LCD2004_WriteString(&LCD2004_conf, "Button to Continue", 18);
			LCD2004_SetCursor(&LCD2004_conf, 3, 0);

			Frequency_Calibrate = false;
			start = false;

			while(!start);
			continue;
		}

		if(Delay_Test){
			LCD2004_ClearScreen(&LCD2004_conf);
			LCD2004_WriteString(&LCD2004_conf, "10ms Delay Test", 15);
			LCD2004_SetCursor(&LCD2004_conf, 1, 0);
			LCD2004_WriteString(&LCD2004_conf, "Scope on PA5", 12);
			LCD2004_SetCursor(&LCD2004_conf, 2, 0);
			LCD2004_WriteString(&LCD2004_conf, "Button when ready", 17);

			Delay_Test = false;
			start = false;

			while(!start);

			GPIO_WriteToPin(&PA5, 0);
			// Avoid function to minimize overhead
			unsigned duration = 10;
			SET(PA5.pGPIOx->ODR, PA5.PinConfig.pin, 1, 0x1);
			msec_delay(duration);
			CLEAR(PA5.pGPIOx->ODR, PA5.PinConfig.pin, 0x1);
			msec_delay(duration);
			SET(PA5.pGPIOx->ODR, PA5.PinConfig.pin, 1, 0x1);
			msec_delay(duration);
			CLEAR(PA5.pGPIOx->ODR, PA5.PinConfig.pin, 0x1);
			msec_delay(duration);
			SET(PA5.pGPIOx->ODR, PA5.PinConfig.pin, 1, 0x1);
			msec_delay(duration);
			CLEAR(PA5.pGPIOx->ODR, PA5.PinConfig.pin, 0x1);
			msec_delay(duration);
			SET(PA5.pGPIOx->ODR, PA5.PinConfig.pin, 1, 0x1);
			msec_delay(duration);
			CLEAR(PA5.pGPIOx->ODR, PA5.PinConfig.pin, 0x1);
			msec_delay(duration);
			SET(PA5.pGPIOx->ODR, PA5.PinConfig.pin, 1, 0x1);
			msec_delay(duration);
			CLEAR(PA5.pGPIOx->ODR, PA5.PinConfig.pin, 0x1);
			msec_delay(duration);
			SET(PA5.pGPIOx->ODR, PA5.PinConfig.pin, 1, 0x1);
			msec_delay(duration);
			CLEAR(PA5.pGPIOx->ODR, PA5.PinConfig.pin, 0x1);
			msec_delay(duration);

			LCD2004_ClearScreen(&LCD2004_conf);
			LCD2004_WriteString(&LCD2004_conf, "Delay Test Done", 15);
			LCD2004_SetCursor(&LCD2004_conf, 1, 0);
			LCD2004_WriteString(&LCD2004_conf, "Button to Continue", 18);

			start = false;
			while(!start);
			continue;
		}

		LCD2004_ClearScreen(&LCD2004_conf);
		unsigned sys_time = get_sys_msec();
		unsigned sys_clk = get_sys_tick();
		unsigned cycle = RTC_Cycle;
		char time_buffer[10];

		utoa(sys_time, time_buffer, 10);
		LCD2004_WriteString(&LCD2004_conf, "Systime: ", 9);
		LCD2004_WriteString(&LCD2004_conf, time_buffer, 10);
		LCD2004_SetCursor(&LCD2004_conf, 1, 0);

		memset(time_buffer, 0, 10);
		utoa(sys_clk, time_buffer, 10);

		LCD2004_WriteString(&LCD2004_conf, "Sysclk: ", 8);
		LCD2004_WriteString(&LCD2004_conf, time_buffer, 10);
		LCD2004_SetCursor(&LCD2004_conf, 2, 0);

		memset(time_buffer, 0, 10);
		utoa(systick_overlap, time_buffer, 10);

		LCD2004_WriteString(&LCD2004_conf, "Tick overlap: ", 14);
		LCD2004_WriteString(&LCD2004_conf, time_buffer, 6);
		LCD2004_SetCursor(&LCD2004_conf, 3, 0);

		memset(time_buffer, 0, 10);
		utoa(cycle, time_buffer, 10);

		LCD2004_WriteString(&LCD2004_conf, "RTC cycle: ", 11);
		LCD2004_WriteString(&LCD2004_conf, time_buffer, 9);
		LCD2004_SetCursor(&LCD2004_conf, 3, 0);

		start = false;
		while(!start);
	}
}

// This app uses I2C2 to communicate with RTC and LCD20x4
void RTC_App(){
	GPIO_Handle_t PA1;	// External timer from DS1307 RTC module - 4.096kHz
	GPIO_Init(&PA1, 'A', 1);
	GPIO_SetModer(&PA1, MODER_INPUT);
	GPIO_IRQConfig(&PA1, GPIO_EXTI_INTERRUPT, GPIO_EXTI_EDGE_RISE);

	LCD2004_Config_t LCD2004_conf = {true, true, true, true, 2, 0, 0};
	LCD2004_Init(&LCD2004_conf);
	LCD2004_WriteString(&LCD2004_conf, "Setting up RTC", 14);
	LCD2004_SetCursor(&LCD2004_conf, 1, 0);

	RTC_Config.I2C_num = 2;
	RTC_Init();
	RTC_set_second(0);
	RTC_set_minute(0);
	RTC_set_hour(0);
	RTC_set_date(0);
	RTC_set_month(0);
	//RTC_set_clock_output(true, 1);

	LCD2004_WriteString(&LCD2004_conf, "RTC Time Set", 12);
	LCD2004_SetCursor(&LCD2004_conf, 2, 0);
	LCD2004_WriteString(&LCD2004_conf, "Button to Continue", 18);

	while(!start);

	while(1){
		LCD2004_ClearScreen(&LCD2004_conf);
		unsigned char sec = RTC_get_second();
		unsigned char min = RTC_get_minute();
		unsigned char hour = RTC_get_hour();
		unsigned char date = RTC_get_date();
		unsigned char mon = RTC_get_month();

		char LCD_buffer[20];
		char time_buffer[2];
		memset(LCD_buffer, 0, 20);
		strcat(LCD_buffer, "Runtime: ");

		itoa(sec, time_buffer, 10);
		strcat(LCD_buffer, time_buffer);
		strcat(LCD_buffer, "s ");

		itoa(min, time_buffer, 10);
		strcat(LCD_buffer, time_buffer);
		strcat(LCD_buffer, "m");

		LCD2004_WriteString(&LCD2004_conf, LCD_buffer, 20);
		LCD2004_SetCursor(&LCD2004_conf, 1, 0);

		memset(LCD_buffer, 0, 20);

		itoa(hour, time_buffer, 10);
		strcat(LCD_buffer, time_buffer);
		strcat(LCD_buffer, "h ");

		itoa(date, time_buffer, 10);
		strcat(LCD_buffer, time_buffer);
		strcat(LCD_buffer, "D ");

		itoa(mon, time_buffer, 10);
		strcat(LCD_buffer, time_buffer);
		strcat(LCD_buffer, "Mo");

		LCD2004_WriteString(&LCD2004_conf, LCD_buffer, 20);
		LCD2004_SetCursor(&LCD2004_conf, 2, 0);
		LCD2004_WriteString(&LCD2004_conf, "Button to Continue", 18);

		start = false;
		while(!start);
	}
}

void matrix_random(short row, short col, unsigned ** matrix, unsigned mod){
	for(short r=0; r < row; r++)
		for(short c=0; c < col; c++){
			if(Random_Number(&matrix[r][c], mod) != 0) // Error detected in RNG
				*((matrix + r*col) + c) = get_sys_tick() & mod;
		}
}

void matrix_mult(void){
	clock_boost(168);

	LCD2004_Config_t LCD2004_conf = {true, true, true, true, 2, 0, 0};
	LCD2004_Init(&LCD2004_conf);
	LCD2004_WriteString(&LCD2004_conf, "Matrix Multiply", 15);
	LCD2004_SetCursor(&LCD2004_conf, 1, 0);

	short rowA = 50, colA = 20, colB = 10, colC = 12, colD = 8, colE = 4, colF = 6, colG = 10, colH = 200;

	unsigned **A, **B, **C, **D, **E, **F, **G, **H, **AB, **CD, **EF, **GH, **ABC, **ABCD, **EFGH, **Final;
	A = (unsigned **) calloc(rowA, sizeof(unsigned *));
	for(short r=0; r<rowA; r++)
		A[r] = (unsigned *) calloc(colA, sizeof(unsigned));

	B = (unsigned **) calloc(colA, sizeof(unsigned *));
	for(short r=0; r<colA; r++)
		B[r] = (unsigned *) calloc(colB, sizeof(unsigned));

	C = (unsigned **) calloc(colB, sizeof(unsigned *));
	for(short r=0; r<colB; r++)
		C[r] = (unsigned *) calloc(colC, sizeof(unsigned));

	D = (unsigned **) calloc(colC, sizeof(unsigned *));
	for(short r=0; r<colC; r++)
		D[r] = (unsigned *) calloc(colD, sizeof(unsigned));

	E = (unsigned **) calloc(colD, sizeof(unsigned *));
	for(short r=0; r<colD; r++)
		E[r] = (unsigned *) calloc(colE, sizeof(unsigned));

	F = (unsigned **) calloc(colE, sizeof(unsigned *));
	for(short r=0; r<colE; r++)
		F[r] = (unsigned *) calloc(colF, sizeof(unsigned));

	G = (unsigned **) calloc(colF, sizeof(unsigned *));
	for(short r=0; r<colF; r++)
		G[r] = (unsigned *) calloc(colG, sizeof(unsigned));

	H = (unsigned **) calloc(colG, sizeof(unsigned *));
	for(short r=0; r<colG; r++)
		H[r] = (unsigned *) calloc(colH, sizeof(unsigned));


	AB = (unsigned **) calloc(rowA, sizeof(unsigned *));
	for(short r=0; r<rowA; r++)
		AB[r] = (unsigned *) calloc(colB, sizeof(unsigned));

	CD = (unsigned **) calloc(colB, sizeof(unsigned *));
	for(short r=0; r<colB; r++)
		CD[r] = (unsigned *) calloc(colD, sizeof(unsigned));

	EF = (unsigned **) calloc(colD, sizeof(unsigned *));
	for(short r=0; r<colD; r++)
		EF[r] = (unsigned *) calloc(colF, sizeof(unsigned));

	GH = (unsigned **) calloc(colF, sizeof(unsigned *));
	for(short r=0; r<colF; r++)
		GH[r] = (unsigned *) calloc(colH, sizeof(unsigned));

	ABCD = (unsigned **) calloc(rowA, sizeof(unsigned *));
	for(short r=0; r<rowA; r++)
		ABCD[r] = (unsigned *) calloc(colD, sizeof(unsigned));

	EFGH = (unsigned **) calloc(colD, sizeof(unsigned *));
	for(short r=0; r<colD; r++)
		EFGH[r] = (unsigned *) calloc(colH, sizeof(unsigned));

	Final = (unsigned **) calloc(rowA, sizeof(unsigned *));
	for(short r=0; r<rowA; r++)
		Final[r] = (unsigned *) calloc(colH, sizeof(unsigned));

	LCD2004_WriteString(&LCD2004_conf, "Button to Start", 15);

	start = false;
	while(!start);

	unsigned init, overlap, elapsed, usec_overlap;
Loop:
	LCD2004_ClearScreen(&LCD2004_conf);

	init = get_sys_tick();

	matrix_random(rowA, colA, A, 10000);
	matrix_random(colA, colB, B, 10000);
	matrix_random(colB, colC, C, 10000);
	matrix_random(colC, colD, D, 10000);
	matrix_random(colD, colE, E, 10000);
	matrix_random(colE, colF, F, 10000);
	matrix_random(colF, colG, G, 10000);
	matrix_random(colG, colH, H, 10000);

	init = get_sys_tick() - init;
	overlap = get_tick_overlap();
	elapsed = get_sys_tick();

	for(short r=0; r < rowA; r++)
		for(short c=0; c < colB; c++){
			AB[r][c] = 0;
			for(short k=0; k < colA; k++)
				AB[r][c] += A[r][k] * B[k][c];
		}

	for(short r=0; r < colB; r++)
		for(short c=0; c < colD; c++){
			CD[r][c] = 0;
			for(short k=0; k < colC; k++)
				CD[r][c] += C[r][k] * D[k][c];
		}

	for(short r=0; r < colD; r++)
		for(short c=0; c < colF; c++){
			EF[r][c] = 0;
			for(short k=0; k < colE; k++)
				EF[r][c] += E[r][k] * F[k][c];
		}

	for(short r=0; r < colF; r++)
		for(short c=0; c < colH; c++){
			GH[r][c] = 0;
			for(short k=0; k < colG; k++)
				GH[r][c] += G[r][k] * H[k][c];
		}

	for(short r=0; r < rowA; r++)
		for(short c=0; c < colD; c++){
			ABCD[r][c] = 0;
			for(short k=0; k < colB; k++)
				ABCD[r][c] += AB[r][k] * CD[k][c];
		}

	for(short r=0; r < colD; r++)
		for(short c=0; c < colH; c++){
			EFGH[r][c] = 0;
			for(short k=0; k < colF; k++)
				EFGH[r][c] += EF[r][k] * GH[k][c];
		}

	for(short r=0; r < rowA; r++)
		for(short c=0; c < colH; c++){
			Final[r][c] = 0;
			for(short k=0; k < colD; k++)
				Final[r][c] += ABCD[r][k] * EFGH[k][c];
		}

	elapsed = get_sys_tick() - elapsed;
	overlap = get_tick_overlap() - overlap;

	usec_overlap = overlap*(0xFFFFFFFF/(apb1_timer/1000000)) + elapsed/(apb1_timer/1000000);

	char buffer[10];
	itoa(elapsed, buffer, 10);

	LCD2004_WriteString(&LCD2004_conf, "Elapsed: ", 9);
	LCD2004_WriteString(&LCD2004_conf, buffer, 10);
	LCD2004_SetCursor(&LCD2004_conf, 1, 0);

	memset(buffer, 0, 10);
	itoa(usec_overlap, buffer, 10);
	LCD2004_WriteString(&LCD2004_conf, "Usec: ", 6);
	LCD2004_WriteString(&LCD2004_conf, buffer, 10);
	LCD2004_SetCursor(&LCD2004_conf, 2, 0);

	memset(buffer, 0, 10);
	itoa(init, buffer, 10);
	LCD2004_WriteString(&LCD2004_conf, "Init: ", 6);
	LCD2004_WriteString(&LCD2004_conf, buffer, 10);
	LCD2004_SetCursor(&LCD2004_conf, 3, 0);

	LCD2004_WriteString(&LCD2004_conf, "Button to restart", 17);

	start = false;
	while(!start);

	goto Loop;
}

void PLL_clock(void){
	// Set sysclk to PLL
	// PLL conf: Source = HSI, M (div) = 8 (Recommended), N (mult) = 168 (336MHz VCO out), P = 2 -> 168MHz (sysclk)
	// AHB scaler = 1 (168MHz, max)
	// APB1 scaler = 4 (42MHz, max)
	// APB2 scaler = 2 (84MHz, max)
	sysclk_conf.output = SYSCLK_PLL;
	sysclk_conf.PLL_src = PLL_SRC_HSE;
	sysclk_conf.PLL_scaler = PLL_Out_Div_2;
	sysclk_conf.VCO_Mult_factor = 336;
	sysclk_conf.VCO_Div_factor = 8;
	sysclk_conf.PLL_Q = 7;
	sysclk_conf.AHB_conf = AHB_Div_1;
	sysclk_conf.APB1_conf = APB_Div_4;
	sysclk_conf.APB2_conf = APB_Div_2;
	SYSCLK_Init(&sysclk_conf);

	GPIO_Handle_t PA3;	// Manual pin for delay function test - oscilloscope required
	GPIO_Init(&PA3, 'A', 3);
	GPIO_SetModer(&PA3, MODER_INPUT);
	GPIO_IRQConfig(&PA3, GPIO_EXTI_INTERRUPT, GPIO_EXTI_EDGE_RISE);

	GPIO_Handle_t PA5;	// In delay test, toggle signal on PA5 every 1ms for 10 times
	GPIO_Init(&PA5, 'A', 5);
	GPIO_SetModer(&PA5, MODER_OUTPUT);

	LCD2004_Config_t LCD2004_conf = {false, false, true, true, 2, 0, 0};
	LCD2004_Init(&LCD2004_conf);

	char buffer[4];
	utoa(sysclk_frequency/1000000, buffer, 10);
	strcat(buffer, "M");
	LCD2004_WriteString(&LCD2004_conf, "Sysclk boost to ", 16);
	LCD2004_WriteString(&LCD2004_conf, buffer, 4);
	LCD2004_SetCursor(&LCD2004_conf, 1, 0);

	LCD2004_WriteString(&LCD2004_conf, "Button to test delay", 20);
	LCD2004_SetCursor(&LCD2004_conf, 2, 0);

	start = false;
	while(1){
		while(!start);

		LCD2004_ClearScreen(&LCD2004_conf);
		LCD2004_WriteString(&LCD2004_conf, "10ms Delay Test", 15);
		LCD2004_SetCursor(&LCD2004_conf, 1, 0);
		LCD2004_WriteString(&LCD2004_conf, "Scope on PA5", 12);
		LCD2004_SetCursor(&LCD2004_conf, 2, 0);
		LCD2004_WriteString(&LCD2004_conf, "Button when ready", 17);

		start = false;
		while(!start);

		GPIO_WriteToPin(&PA5, 0);
		// Avoid function to minimize overhead
		unsigned duration = 1;
		SET(PA5.pGPIOx->ODR, PA5.PinConfig.pin, 1, 0x1);
		msec_delay(duration);
		CLEAR(PA5.pGPIOx->ODR, PA5.PinConfig.pin, 0x1);
		msec_delay(duration);
		SET(PA5.pGPIOx->ODR, PA5.PinConfig.pin, 1, 0x1);
		msec_delay(duration);
		CLEAR(PA5.pGPIOx->ODR, PA5.PinConfig.pin, 0x1);
		msec_delay(duration);
		SET(PA5.pGPIOx->ODR, PA5.PinConfig.pin, 1, 0x1);
		msec_delay(duration);
		CLEAR(PA5.pGPIOx->ODR, PA5.PinConfig.pin, 0x1);
		msec_delay(duration);
		SET(PA5.pGPIOx->ODR, PA5.PinConfig.pin, 1, 0x1);
		msec_delay(duration);
		CLEAR(PA5.pGPIOx->ODR, PA5.PinConfig.pin, 0x1);
		msec_delay(duration);
		SET(PA5.pGPIOx->ODR, PA5.PinConfig.pin, 1, 0x1);
		msec_delay(duration);
		CLEAR(PA5.pGPIOx->ODR, PA5.PinConfig.pin, 0x1);
		msec_delay(duration);
		SET(PA5.pGPIOx->ODR, PA5.PinConfig.pin, 1, 0x1);
		msec_delay(duration);
		CLEAR(PA5.pGPIOx->ODR, PA5.PinConfig.pin, 0x1);

		LCD2004_ClearScreen(&LCD2004_conf);
		LCD2004_WriteString(&LCD2004_conf, "Delay Test Done", 15);
		LCD2004_SetCursor(&LCD2004_conf, 1, 0);
		LCD2004_WriteString(&LCD2004_conf, "Button to re-test", 17);

		start = false;
	}
}

int main(void)
{
	sysclk_conf.output = SYSCLK_HSI;
	sysclk_conf.AHB_conf = AHB_Div_1;
	sysclk_conf.APB1_conf = APB_Div_1;
	sysclk_conf.APB2_conf = APB_Div_1;

	SYSCLK_Init(&sysclk_conf);

	GPIO_Init(&PA0, 'A', 0);	// Button config
	GPIO_Init(&PD13, 'D', 13);

	GPIO_SetModer(&PA0, MODER_INPUT);
	GPIO_SetPull(&PA0, PUPDR_DOWN);

	GPIO_SetModer(&PD13, MODER_OUTPUT);
	GPIO_TogglePin(&PD13);

	GPIO_IRQConfig(&PA0, GPIO_EXTI_INTERRUPT, GPIO_EXTI_EDGE_RISE);

	clock_boost(168);
	//LCD2004_App();
	//I2C2_App();
	//TIM_RTC_Calibrate();
	//RTC_App();
	//matrix_mult();
	while(1){
		Matrix_Chain_Multiplication();
		start = false;
		while(!start);
	}
}


